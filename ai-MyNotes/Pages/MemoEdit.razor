@page "/"
@page "/edit/{id:int?}"
@using ai_MyNotes.Models
@using ai_MyNotes.Services
@using TG.Blazor.IndexedDB
@inject MemoService MemoService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IDisposable

<PageTitle>@(IsEditMode ? $"編集: {CurrentMemo.Title}" : "新規メモ")</PageTitle>

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <!-- ヘッダー -->
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h2>@(IsEditMode ? "メモ編集" : "新規メモ")</h2>
                <div>
                    <button class="btn btn-outline-secondary me-2" @onclick="NavigateToList">
                        <i class="bi bi-list-ul"></i> 一覧
                    </button>
                    @if (IsEditMode)
                    {
                        <button class="btn btn-danger" @onclick="DeleteMemo" disabled="@isSaving">
                            <i class="bi bi-trash"></i> 削除
                        </button>
                    }
                </div>
            </div>

            <!-- 保存状態表示 -->
            @if (!string.IsNullOrEmpty(statusMessage))
            {
                <div class="alert @(statusMessage.Contains("エラー") ? "alert-danger" : "alert-success") alert-dismissible fade show" role="alert">
                    @statusMessage
                    <button type="button" class="btn-close" @onclick="ClearStatus"></button>
                </div>
            }

            <!-- 保存状態インジケーター -->
            <div class="save-status-bar mb-3">
                @if (isSaving)
                {
                    <div class="d-flex align-items-center">
                        <div class="spinner-border spinner-border-sm me-2" role="status">
                            <span class="visually-hidden">保存中...</span>
                        </div>
                        <small class="text-primary fw-semibold">
                            <i class="bi bi-cloud-upload"></i> 保存中...
                        </small>
                    </div>
                }
                else if (saveError)
                {
                    <div class="d-flex align-items-center text-danger">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <small class="fw-semibold">保存に失敗しました</small>
                        <button class="btn btn-outline-danger btn-sm ms-2" @onclick="RetrySave">
                            <i class="bi bi-arrow-clockwise"></i> 再試行
                        </button>
                    </div>
                }
                else if (lastSavedAt != null)
                {
                    <div class="d-flex align-items-center">
                        <i class="bi bi-check-circle-fill text-success me-2"></i>
                        <small class="text-success">
                            保存完了: @lastSavedAt?.ToString("MM/dd HH:mm:ss")
                        </small>
                        @if (hasUnsavedChanges)
                        {
                            <small class="text-warning ms-3">
                                <i class="bi bi-pencil-square"></i> 編集中（@autoSaveCountdown 秒後に自動保存）
                            </small>
                        }
                    </div>
                }
                else if (isNewMemo)
                {
                    <div class="d-flex align-items-center">
                        <i class="bi bi-file-earmark-plus text-info me-2"></i>
                        <small class="text-info">新規メモ作成中...</small>
                    </div>
                }
            </div>

            <!-- メモ編集エリア（Bootstrap強化） -->
            <div class="mb-3 flex-grow-1 d-flex flex-column">
                <label for="memoContent" class="form-label fw-semibold">
                    メモ内容
                    <span class="badge bg-info ms-2">1行目が自動的にタイトルになります</span>
                </label>
                <div class="form-floating flex-grow-1 d-flex flex-column">
                    <textarea @bind="CurrentMemo.Content"
                             @oninput="OnContentInput"
                             @onfocusout="OnFocusOut"
                             @onbeforeunload="OnBeforeUnload"
                             class="form-control flex-grow-1 resize-none" 
                             id="memoContent" 
                             style="min-height: 400px; height: 100%;"
                             placeholder="メモを入力してください..."
                             disabled="@isSaving"
                             spellcheck="false"></textarea>
                    <label for="memoContent" class="text-muted">
                        メモ内容を入力...
                    </label>
                </div>
                
                <!-- 文字数カウンター -->
                <div class="d-flex justify-content-between align-items-center mt-2">
                    <small class="text-muted">
                        <i class="bi bi-type"></i>
                        文字数: <span class="fw-bold">@(CurrentMemo.Content?.Length ?? 0)</span> / 10,000
                        @if (CurrentMemo.Content?.Length > 8000)
                        {
                            <span class="text-warning ms-2">(残り @(10000 - CurrentMemo.Content.Length) 文字)</span>
                        }
                    </small>
                    <div class="text-end">
                        @if (hasUnsavedChanges)
                        {
                            <small class="text-warning">
                                <i class="bi bi-exclamation-triangle"></i> 未保存の変更があります
                            </small>
                        }
                        else if (lastSavedAt.HasValue)
                        {
                            <small class="text-success">
                                <i class="bi bi-check-circle"></i> 保存済み
                            </small>
                        }
                    </div>
                </div>
            </div>

            <!-- メモ情報 -->
            @if (IsEditMode)
            {
                <div class="row">
                    <div class="col-md-6">
                        <small class="text-muted">
                            <strong>作成:</strong> @CurrentMemo.CreatedAt.ToString("yyyy/MM/dd HH:mm:ss")
                        </small>
                    </div>
                    <div class="col-md-6">
                        <small class="text-muted">
                            <strong>更新:</strong> @CurrentMemo.UpdatedAt.ToString("yyyy/MM/dd HH:mm:ss")
                        </small>
                    </div>
                </div>
            }
        </div>
    </div>
</div>

@code {
    [Parameter] public int? Id { get; set; }

    private Memo CurrentMemo = new Memo();
    private Memo OriginalMemo = new Memo(); // 変更検知用の元データ
    private bool IsEditMode => Id.HasValue && Id.Value > 0;
    private bool isNewMemo => !IsEditMode;
    private bool isSaving = false;
    private bool saveError = false;
    private bool hasUnsavedChanges = false;
    private string statusMessage = "";
    private DateTime? lastSavedAt = null;
    private Timer? autoSaveTimer;
    private Timer? countdownTimer;
    private CancellationTokenSource? cancellationTokenSource;
    private string? lastContent = ""; // 前回の内容（変更検知用）
    private int autoSaveCountdown = 0; // 自動保存カウントダウン
    private readonly object saveLock = new object(); // 競合処理回避用ロック
    private bool isAutoSaveEnabled = true; // 自動保存の有効/無効

    protected override async Task OnInitializedAsync()
    {
        cancellationTokenSource = new CancellationTokenSource();

        if (IsEditMode && Id.HasValue)
        {
            await LoadMemo(Id.Value);
        }
        else
        {
            // 新規メモの場合
            CurrentMemo = new Memo();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // パラメータが変更された場合（異なるIDでナビゲーションした場合）
        if (IsEditMode && Id.HasValue)
        {
            await LoadMemo(Id.Value);
        }
    }

    private async Task LoadMemo(int id)
    {
        try
        {
            var memo = await MemoService.GetMemoByIdAsync(id);
            if (memo != null)
            {
                CurrentMemo = memo;
                OriginalMemo = new Memo 
                { 
                    Id = memo.Id, 
                    Title = memo.Title, 
                    Content = memo.Content, 
                    CreatedAt = memo.CreatedAt, 
                    UpdatedAt = memo.UpdatedAt 
                }; // 元データをコピー
                lastSavedAt = memo.UpdatedAt;
                lastContent = memo.Content;
                hasUnsavedChanges = false;
            }
            else
            {
                statusMessage = "エラー: メモが見つかりませんでした";
                await Task.Delay(3000);
                await NavigateToList();
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"エラー: {ex.Message}";
        }
    }

    private void OnContentInput(ChangeEventArgs e)
    {
        // 内容の変更を検知
        var newContent = e.Value?.ToString() ?? "";
        CurrentMemo.Content = newContent;
        
        // 変更フラグの更新
        hasUnsavedChanges = !IsContentEqual(CurrentMemo.Content, lastContent);
        
        // リアルタイムタイトル生成
        if (!string.IsNullOrWhiteSpace(CurrentMemo.Content))
        {
            var tempMemo = new Memo { Content = CurrentMemo.Content };
            tempMemo.UpdateTitleFromContent();
            CurrentMemo.Title = tempMemo.Title;
        }
        
        // 自動保存タイマーをリセット（3秒後に保存、debounce処理）
        ResetAutoSaveTimer();
        
        StateHasChanged();
    }

    private bool IsContentEqual(string? content1, string? content2)
    {
        return string.Equals(content1?.Trim() ?? "", content2?.Trim() ?? "", StringComparison.Ordinal);
    }

    private async Task OnFocusOut()
    {
        // フォーカス離脱時は即座に保存（優先処理、タイマーをキャンセル）
        CancelAutoSaveTimer();
        if (hasUnsavedChanges && !isSaving)
        {
            await SaveMemo();
        }
    }

    private async Task AutoSave()
    {
        if (!isSaving)
        {
            await SaveMemo();
        }
    }

    private async Task SaveMemo()
    {
        // 競合処理の回避（ロック機構）
        lock (saveLock)
        {
            if (isSaving || string.IsNullOrWhiteSpace(CurrentMemo.Content))
                return;
            
            isSaving = true;
        }

        saveError = false;
        statusMessage = "";

        try
        {
            if (cancellationTokenSource?.Token.IsCancellationRequested == true)
                return;

            // バリデーション実行
            var (isValid, errors) = CurrentMemo.Validate();
            if (!isValid)
            {
                statusMessage = $"バリデーションエラー: {string.Join(", ", errors)}";
                saveError = true;
                return;
            }

            CurrentMemo.UpdateTitleFromContent();
            CurrentMemo.Touch();

            // 保存処理実行
            if (IsEditMode)
            {
                await MemoService.UpdateMemoAsync(CurrentMemo);
                statusMessage = "メモを更新しました";
            }
            else
            {
                var savedMemo = await MemoService.CreateMemoAsync(CurrentMemo);
                CurrentMemo = savedMemo;
                statusMessage = "メモを作成しました";
                
                // 新規作成後は編集モードに移行（URL更新）
                Id = CurrentMemo.Id;
                Navigation.NavigateTo($"/edit/{CurrentMemo.Id}", replace: true);
            }

            // 保存成功時の状態更新
            lastSavedAt = DateTime.Now;
            lastContent = CurrentMemo.Content;
            hasUnsavedChanges = false;
            saveError = false;
            
            // 元データを更新（変更検知用）
            OriginalMemo.Content = CurrentMemo.Content;
            OriginalMemo.Title = CurrentMemo.Title;
            OriginalMemo.UpdatedAt = CurrentMemo.UpdatedAt;
            
            // JavaScript状態の更新
            await JSRuntime.InvokeVoidAsync("eval", "window.hasUnsavedChanges = false;");
            
            StateHasChanged();
            
            // 成功フィードバックを3秒後に自動クリア
            await Task.Delay(3000);
            if (!cancellationTokenSource?.Token.IsCancellationRequested == true)
            {
                statusMessage = "";
                StateHasChanged();
            }
        }
        catch (TaskCanceledException)
        {
            // キャンセル処理（正常終了）
            statusMessage = "";
        }
        catch (Exception ex)
        {
            // エラーハンドリングの改善
            saveError = true;
            statusMessage = $"保存に失敗しました: {ex.Message}";
            
            // エラー詳細のログ出力
            Console.WriteLine($"Save error: {ex}");
            
            // エラー時は自動保存を一時的に無効化（1分間）
            isAutoSaveEnabled = false;
            _ = Task.Run(async () =>
            {
                await Task.Delay(TimeSpan.FromMinutes(1));
                isAutoSaveEnabled = true;
            });
        }
        finally
        {
            isSaving = false;
            if (!cancellationTokenSource?.Token.IsCancellationRequested == true)
            {
                StateHasChanged();
            }
        }
    }

    private async Task DeleteMemo()
    {
        if (!IsEditMode || CurrentMemo.Id <= 0)
            return;

        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"メモ「{CurrentMemo.Title}」を削除しますか？");
        if (!confirmed)
            return;

        try
        {
            await MemoService.DeleteMemoAsync(CurrentMemo.Id);
            statusMessage = "メモを削除しました";
            await Task.Delay(1000);
            await NavigateToList();
        }
        catch (Exception ex)
        {
            statusMessage = $"エラー: {ex.Message}";
        }
    }

    private async Task NavigateToList()
    {
        // 未保存の変更がある場合の確認
        if (hasUnsavedChanges)
        {
            var shouldSave = await JSRuntime.InvokeAsync<bool>("confirm", 
                "未保存の変更があります。保存してから移動しますか？\n" +
                "「OK」で保存してから移動、「キャンセル」で保存せずに移動します。");
            
            if (shouldSave)
            {
                await SaveMemo();
            }
        }
        
        Navigation.NavigateTo("/list");
    }

    private void ClearStatus()
    {
        statusMessage = "";
    }

    // ページ離脱時の警告（beforeunload イベント）
    private async Task OnBeforeUnload()
    {
        if (hasUnsavedChanges)
        {
            await JSRuntime.InvokeVoidAsync("eval", @"
                window.addEventListener('beforeunload', function(e) {
                    if (window.hasUnsavedChanges) {
                        e.preventDefault();
                        e.returnValue = '';
                        return '';
                    }
                });
            ");
            
            await JSRuntime.InvokeVoidAsync("eval", "window.hasUnsavedChanges = true;");
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("eval", "window.hasUnsavedChanges = false;");
        }
    }

    // コンポーネントマウント後にJSイベントリスナーを設定
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // beforeunload イベントの設定
            await JSRuntime.InvokeVoidAsync("eval", @"
                window.hasUnsavedChanges = false;
                window.addEventListener('beforeunload', function(e) {
                    if (window.hasUnsavedChanges) {
                        e.preventDefault();
                        e.returnValue = '未保存の変更があります。ページを離れますか？';
                        return '未保存の変更があります。ページを離れますか？';
                    }
                });
                
                // Blazor コンポーネント向けの状態更新関数
                window.setUnsavedChanges = function(hasChanges) {
                    window.hasUnsavedChanges = hasChanges;
                };
            ");
        }

        // 未保存状態をJavaScriptに通知
        if (hasUnsavedChanges)
        {
            await JSRuntime.InvokeVoidAsync("eval", "window.hasUnsavedChanges = true;");
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("eval", "window.hasUnsavedChanges = false;");
        }
    }

    // 自動保存前の最終確認（重複保存防止）
    private async Task ForceSaveBeforeExit()
    {
        if (hasUnsavedChanges && !isSaving && !string.IsNullOrWhiteSpace(CurrentMemo.Content))
        {
            try
            {
                await SaveMemo();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Exit save failed: {ex.Message}");
            }
        }
    }
    
    // 自動保存タイマーのリセット（debounce処理）
    private void ResetAutoSaveTimer()
    {
        if (!isAutoSaveEnabled) return;
        
        CancelAutoSaveTimer();
        
        // カウントダウンタイマーを開始
        autoSaveCountdown = 3;
        countdownTimer = new Timer(async _ =>
        {
            autoSaveCountdown--;
            await InvokeAsync(StateHasChanged);
            
            if (autoSaveCountdown <= 0)
            {
                countdownTimer?.Dispose();
                countdownTimer = null;
                
                if (hasUnsavedChanges && !isSaving)
                {
                    await InvokeAsync(async () => await AutoSave());
                }
            }
        }, null, 1000, 1000);
        
        // メインの自動保存タイマー
        autoSaveTimer = new Timer(async _ => 
        {
            if (hasUnsavedChanges && !isSaving)
            {
                await InvokeAsync(async () => await AutoSave());
            }
        }, null, 3000, Timeout.Infinite);
    }
    
    // 自動保存タイマーのキャンセル
    private void CancelAutoSaveTimer()
    {
        autoSaveTimer?.Dispose();
        autoSaveTimer = null;
        countdownTimer?.Dispose();
        countdownTimer = null;
        autoSaveCountdown = 0;
    }
    
    // 再試行処理
    private async Task RetrySave()
    {
        saveError = false;
        await SaveMemo();
    }

    public void Dispose()
    {
        // 終了時に未保存の変更があれば保存を試行
        if (hasUnsavedChanges && !string.IsNullOrWhiteSpace(CurrentMemo.Content))
        {
            // 同期的に保存を試行（Disposeは非同期メソッドを呼べない）
            Task.Run(async () => await ForceSaveBeforeExit());
        }

        CancelAutoSaveTimer();
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
        
        // JavaScriptの状態もクリア
        try
        {
            JSRuntime.InvokeVoidAsync("eval", "window.hasUnsavedChanges = false;");
        }
        catch
        {
            // Dispose時にJSRuntimeが使用できない場合があるので例外は無視
        }
    }
}

<style>
/* 保存状態インジケーターのスタイル */
.save-status-bar {
    min-height: 2rem;
    padding: 0.5rem;
    border-radius: 0.375rem;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    transition: all 0.3s ease;
}

.save-status-bar:empty {
    display: none;
}

/* 保存中のアニメーション */
.save-status-bar .spinner-border-sm {
    width: 1rem;
    height: 1rem;
    animation: spin 1s linear infinite;
}

@@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* 保存成功時のフェードイン効果 */
.save-status-bar .text-success {
    animation: fadeIn 0.5s ease-in;
}

@@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* エラー状態の強調 */
.save-status-bar .text-danger {
    animation: shake 0.5s ease-in-out;
}

@@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

/* カウントダウン表示のスタイル */
.save-status-bar .text-warning {
    font-weight: 500;
}

/* レスポンシブ対応 */
@@media (max-width: 768px) {
    .save-status-bar {
        font-size: 0.875rem;
    }
    
    .save-status-bar .btn-sm {
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
    }
}

/* テキストエリアのフォーカス時スタイル */
.form-control:focus {
    border-color: #86b7fe;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}

/* 文字数カウンター */
.character-counter {
    transition: color 0.3s ease;
}

.character-counter.warning {
    color: #fd7e14 !important;
}

.character-counter.danger {
    color: #dc3545 !important;
}
</style>