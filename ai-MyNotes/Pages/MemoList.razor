@page "/list"
@using ai_MyNotes.Models
@using ai_MyNotes.Services
@inject IMemoService MemoService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IDisposable

<PageTitle>メモ一覧</PageTitle>

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <!-- ヘッダー -->
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2>メモ一覧</h2>
                <button class="btn btn-primary" @onclick="CreateNewMemo">
                    <i class="bi bi-plus-circle"></i> 新規作成
                </button>
            </div>

            <!-- ステータスメッセージ -->
            @if (!string.IsNullOrEmpty(statusMessage))
            {
                <div class="alert @(statusMessage.Contains("エラー") ? "alert-danger" : "alert-info") alert-dismissible fade show" role="alert">
                    @statusMessage
                    <button type="button" class="btn-close" @onclick="ClearStatus"></button>
                </div>
            }

            <!-- ローディング表示 -->
            @if (isLoading)
            {
                <div class="d-flex justify-content-center">
                    <div class="spinner-border" role="status">
                        <span class="visually-hidden">読み込み中...</span>
                    </div>
                </div>
            }
            else
            {
                <!-- メモ一覧 -->
                @if (memos?.Any() == true)
                {
                    <div class="row">
                        @foreach (var memo in memos)
                        {
                            <div class="col-12 col-md-6 col-lg-4 mb-3">
                                <!-- スワイプ対応メモカード -->
                                <div class="memo-card-container position-relative overflow-hidden" data-memo-id="@memo.Id">
                                    <div class="memo-card h-100 card" 
                                         @onclick="() => EditMemo(memo.Id)"
                                         @ontouchstart="@((TouchEventArgs e) => OnTouchStart(e, memo.Id))"
                                         @ontouchmove="@((TouchEventArgs e) => OnTouchMove(e, memo.Id))"
                                         @ontouchend="@((TouchEventArgs e) => OnTouchEnd(e, memo.Id))"
                                         @ontouchcancel="@((TouchEventArgs e) => OnTouchCancel(e, memo.Id))">
                                        <div class="card-body d-flex flex-column">
                                            <h5 class="card-title text-truncate fw-semibold">@memo.Title</h5>
                                            <p class="card-text flex-grow-1 memo-preview">
                                                @memo.GetPreview(120)
                                            </p>
                                            <div class="mt-auto">
                                                <small class="text-muted d-block mb-1">
                                                    <i class="bi bi-calendar-event me-1"></i> 
                                                    作成: @memo.CreatedAt.ToString("MM/dd HH:mm")
                                                </small>
                                                @if (memo.UpdatedAt != memo.CreatedAt)
                                                {
                                                    <small class="text-muted d-block">
                                                        <i class="bi bi-pencil-square me-1"></i> 
                                                        更新: @memo.UpdatedAt.ToString("MM/dd HH:mm")
                                                    </small>
                                                }
                                            </div>
                                        </div>
                                        
                                        <!-- ホバー削除ボタン（デスクトップ用） -->
                                        <button class="btn btn-outline-danger btn-sm memo-delete-btn position-absolute top-0 end-0 m-2" 
                                               @onclick="(e) => DeleteMemo(memo, e)" 
                                               @onclick:stopPropagation="true"
                                               title="削除">
                                            <i class="bi bi-trash"></i>
                                        </button>
                                    </div>
                                    
                                    <!-- 左スワイプで表示される削除ボタン -->
                                    <div class="delete-action position-absolute top-0 end-0 h-100 d-flex align-items-center justify-content-center"
                                         style="width: 80px; background: #dc3545; color: white; transform: translateX(100%); transition: transform 0.3s ease;">
                                        <button class="btn btn-link text-white p-2" 
                                               @onclick="(e) => DeleteMemo(memo, e)"
                                               @onclick:stopPropagation="true"
                                               title="削除">
                                            <i class="bi bi-trash-fill fs-4"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                }
                else
                {
                    <!-- 空の状態 -->
                    <div class="text-center py-5">
                        <i class="bi bi-journal-text display-1 text-muted"></i>
                        <h4 class="mt-3 text-muted">メモがありません</h4>
                        <p class="text-muted">新規作成ボタンを押してメモを作成しましょう</p>
                        <button class="btn btn-primary" @onclick="CreateNewMemo">
                            <i class="bi bi-plus-circle"></i> 最初のメモを作成
                        </button>
                    </div>
                }
            }
        </div>
    </div>
</div>

<style>
/* メモカードコンテナ */
.memo-card-container {
    position: relative;
    overflow: hidden;
    border-radius: 0.375rem;
}

.memo-card {
    cursor: pointer;
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    position: relative;
    border: 1px solid rgba(0,0,0,.125);
    border-radius: 0.375rem;
    background: white;
    user-select: none;
    -webkit-user-select: none;
}

.memo-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.15);
    border-color: rgba(0,0,0,.175);
}

.memo-card .card-title {
    margin-bottom: 0.75rem;
    font-weight: 600;
    color: #212529;
}

.memo-preview {
    font-size: 0.9rem;
    line-height: 1.4;
    color: #6c757d;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    text-overflow: ellipsis;
    min-height: 3.6rem; /* 3行分の最小高さ確保 */
}

/* デスクトップ用削除ボタン */
.memo-delete-btn {
    opacity: 0;
    transition: all 0.2s ease-in-out;
    --bs-btn-border-width: 1px;
    z-index: 10;
}

.memo-card:hover .memo-delete-btn {
    opacity: 1;
}

.memo-delete-btn:hover {
    transform: scale(1.1);
}

/* 左スワイプ削除アクション - Enhanced */
.delete-action {
    z-index: 5;
    background: linear-gradient(135deg, var(--bs-danger, #dc2626) 0%, #b91c1c 100%);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 0 var(--border-radius, 0.5rem) var(--border-radius, 0.5rem) 0;
}

.delete-action::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.1) 100%);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.delete-action:hover::before {
    opacity: 1;
}

/* Enhanced swipe animations */
.memo-card.swiping {
    transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    will-change: transform;
}

.memo-card.swipe-delete {
    transform: translateX(-80px);
    box-shadow: 0 4px 12px rgba(220, 38, 38, 0.15), -2px 0 8px rgba(220, 38, 38, 0.1);
}

.memo-card.swipe-delete + .delete-action {
    transform: translateX(0) !important;
    box-shadow: inset 2px 0 4px rgba(0, 0, 0, 0.1);
}

/* Swipe feedback animation */
.memo-card.swipe-delete + .delete-action .btn {
    animation: pulseDelete 0.6s ease-in-out;
}

@@keyframes pulseDelete {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

/* Swipe threshold visual feedback */
.memo-card.swipe-threshold {
    transform: translateX(-100px) !important;
    transition: transform 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

.memo-card.swipe-threshold + .delete-action {
    transform: translateX(-20px) !important;
    box-shadow: 0 6px 20px rgba(220, 38, 38, 0.3), inset 2px 0 4px rgba(0, 0, 0, 0.15);
}

.memo-card.swipe-threshold + .delete-action::before {
    opacity: 1;
}

/* Bouncy reset animation */
.memo-card.swipe-reset {
    animation: bounceBack 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    transform: translateX(0);
}

@@keyframes bounceBack {
    0% { transform: translateX(-80px); }
    60% { transform: translateX(10px); }
    100% { transform: translateX(0); }
}

/* レスポンシブ対応 */
@@media (max-width: 768px) {
    .memo-card {
        touch-action: pan-y; /* 縦スクロールは許可、横スワイプを検知 */
    }
    
    .memo-delete-btn {
        display: none; /* モバイルではホバーボタンを非表示 */
    }
    
    .memo-preview {
        -webkit-line-clamp: 2; /* モバイルでは2行表示 */
        min-height: 2.4rem;
    }
}

@@media (min-width: 769px) {
    .delete-action {
        display: none !important; /* デスクトップではスワイプ削除アクションを非表示 */
    }
}

/* アニメーション改善 */
.memo-card-container:hover .memo-card {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0,0,0,0.15);
}

/* アクセシビリティ */
.memo-card:focus {
    outline: 2px solid #0d6efd;
    outline-offset: 2px;
}

/* 状態表示改善 */
.text-muted {
    color: #6c757d !important;
}

.text-muted i {
    opacity: 0.8;
}
</style>

@code {
    private List<Memo> memos = new List<Memo>();
    private bool isLoading = false;
    private string statusMessage = "";
    private CancellationTokenSource? cancellationTokenSource;
    
    // タッチ・スワイプ関連の状態管理
    private Dictionary<int, TouchState> touchStates = new Dictionary<int, TouchState>();
    
    private class TouchState
    {
        public double StartX { get; set; }
        public double StartY { get; set; }
        public double CurrentX { get; set; }
        public double CurrentY { get; set; }
        public bool IsSwiping { get; set; }
        public bool IsSwipeDeleteActive { get; set; }
        public DateTime StartTime { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        cancellationTokenSource = new CancellationTokenSource();
        await LoadMemos();
    }

    private async Task LoadMemos()
    {
        isLoading = true;
        statusMessage = "";
        
        try
        {
            if (cancellationTokenSource?.Token.IsCancellationRequested == true)
                return;

            memos = await MemoService.GetMemosAsync();
            
            if (memos.Count == 0)
            {
                statusMessage = "";
            }
            else
            {
                statusMessage = $"{memos.Count}件のメモが見つかりました";
                // 3秒後にメッセージをクリア
                await Task.Delay(3000);
                if (!cancellationTokenSource?.Token.IsCancellationRequested == true)
                {
                    statusMessage = "";
                    StateHasChanged();
                }
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"エラー: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            if (!cancellationTokenSource?.Token.IsCancellationRequested == true)
            {
                StateHasChanged();
            }
        }
    }

    private void CreateNewMemo()
    {
        Navigation.NavigateTo("");
    }

    private void EditMemo(int memoId)
    {
        Navigation.NavigateTo($"edit/{memoId}");
    }

    private async Task DeleteMemo(Memo memo, MouseEventArgs e)
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", $"メモ「{memo.Title}」を削除しますか？");
        if (!confirmed)
            return;

        try
        {
            await MemoService.DeleteMemoAsync(memo.Id);
            statusMessage = $"メモ「{memo.Title}」を削除しました";
            
            // 一覧を再読み込み
            await LoadMemos();
        }
        catch (Exception ex)
        {
            statusMessage = $"エラー: {ex.Message}";
        }
    }

    private void ClearStatus()
    {
        statusMessage = "";
    }

    // タッチイベントハンドラー - Enhanced with error handling
    private void OnTouchStart(TouchEventArgs e, int memoId)
    {
        if (e.Touches.Length == 0) return;
        
        try
        {
            var touch = e.Touches[0];
            touchStates[memoId] = new TouchState
            {
                StartX = touch.ClientX,
                StartY = touch.ClientY,
                CurrentX = touch.ClientX,
                CurrentY = touch.ClientY,
                StartTime = DateTime.Now,
                IsSwiping = false,
                IsSwipeDeleteActive = false
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Touch start error for memo {memoId}: {ex.Message}");
            // 安全な初期化
            touchStates[memoId] = new TouchState
            {
                StartX = 0,
                StartY = 0,
                CurrentX = 0,
                CurrentY = 0,
                StartTime = DateTime.Now,
                IsSwiping = false,
                IsSwipeDeleteActive = false
            };
        }
    }
    
    private async Task OnTouchMove(TouchEventArgs e, int memoId)
    {
        if (e.Touches.Length == 0 || !touchStates.ContainsKey(memoId)) return;
        
        try
        {
            var touch = e.Touches[0];
            var state = touchStates[memoId];
            
            state.CurrentX = touch.ClientX;
            state.CurrentY = touch.ClientY;
            
            var deltaX = state.StartX - state.CurrentX;
            var deltaY = Math.Abs(state.StartY - state.CurrentY);
            
            // 水平方向のスワイプかどうかを判定（縦スクロールと区別）
            if (Math.Abs(deltaX) > 10 && Math.Abs(deltaX) > deltaY * 2)
            {
                if (!state.IsSwiping)
                {
                    state.IsSwiping = true;
                    await JSRuntime.InvokeVoidAsync("setSwipeState", $"[data-memo-id='{memoId}'] .memo-card", "swiping");
                }
                
                // Enhanced swipe thresholds with better visual feedback
                if (deltaX > 150) // Threshold for immediate visual feedback
                {
                    if (!state.IsSwipeDeleteActive)
                    {
                        state.IsSwipeDeleteActive = true;
                        await JSRuntime.InvokeVoidAsync("setSwipeState", $"[data-memo-id='{memoId}'] .memo-card", "threshold");
                    }
                }
                else if (deltaX > 100) // Standard delete activation
                {
                    if (!state.IsSwipeDeleteActive)
                    {
                        state.IsSwipeDeleteActive = true;
                        await JSRuntime.InvokeVoidAsync("setSwipeState", $"[data-memo-id='{memoId}'] .memo-card", "delete");
                    }
                }
                else if (state.IsSwipeDeleteActive && deltaX < 80)
                {
                    // スワイプが80px未満に戻った場合は削除状態をリセット
                    state.IsSwipeDeleteActive = false;
                    await JSRuntime.InvokeVoidAsync("setSwipeState", $"[data-memo-id='{memoId}'] .memo-card", "reset");
                }
            }
        }
        catch (Exception ex)
        {
            // エラーハンドリング: タッチイベントの失敗は致命的ではない
            Console.WriteLine($"Touch move error for memo {memoId}: {ex.Message}");
            // 状態を安全にリセット
            if (touchStates.ContainsKey(memoId))
            {
                touchStates[memoId].IsSwiping = false;
                touchStates[memoId].IsSwipeDeleteActive = false;
            }
        }
    }
    
    private async Task OnTouchEnd(TouchEventArgs e, int memoId)
    {
        if (!touchStates.ContainsKey(memoId)) return;
        
        try
        {
            var state = touchStates[memoId];
            
            // スワイプ削除状態が非アクティブの場合は元に戻す
            if (state.IsSwiping && !state.IsSwipeDeleteActive)
            {
                await JSRuntime.InvokeVoidAsync("setSwipeState", $"[data-memo-id='{memoId}'] .memo-card", "reset");
            }
            else if (!state.IsSwiping)
            {
                // 通常のタップ操作の場合は何もしない（EditMemo呼び出しを妨げない）
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Touch end error for memo {memoId}: {ex.Message}");
            // フォールバック: 強制的にスワイプ状態をリセット
            try
            {
                await JSRuntime.InvokeVoidAsync("resetAllSwipeStates");
            }
            catch (Exception resetEx)
            {
                Console.WriteLine($"Failed to reset swipe states: {resetEx.Message}");
            }
        }
        finally
        {
            // 状態をクリア
            touchStates.Remove(memoId);
        }
    }
    
    private async Task OnTouchCancel(TouchEventArgs e, int memoId)
    {
        if (!touchStates.ContainsKey(memoId)) return;
        
        try
        {
            // キャンセル時は削除状態をリセット
            await JSRuntime.InvokeVoidAsync("setSwipeState", $"[data-memo-id='{memoId}'] .memo-card", "reset");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Touch cancel error for memo {memoId}: {ex.Message}");
            // フォールバック: 強制的にスワイプ状態をリセット
            try
            {
                await JSRuntime.InvokeVoidAsync("resetAllSwipeStates");
            }
            catch (Exception resetEx)
            {
                Console.WriteLine($"Failed to reset swipe states on cancel: {resetEx.Message}");
            }
        }
        finally
        {
            touchStates.Remove(memoId);
        }
    }

    public void Dispose()
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
    }
}